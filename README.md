
# Vulnerability 

EdgeVPN uses ProtocolLab's go-libp2p library and its Distributed Hash Table(DHT, a distributed key-value storage) 
as a pubsub system, thus EdgeVPN instances are able to exchange messages containing VPN configuration over the DHT.

An attacker is able to quickly guess a cryptographic key used to encrypt EdgeVPN configuration 
and then modify the configuration joining the private enterprise network.

# Details
Let's assume we have two nodes: node1 and node2. Both are running edgevpn and sharing the same token generated by `edgevpn -g`.
The nodes send/receive messages over the same pubsub channel, and this channel is rotated every 15 minutes by default.

The node workflow looks as follows:
```text
* periodically:
    * rotate the current pubsub channel:
          topic name = MD5(OTP1) 
          // OTP1 - Time-based OTP based on `edgevpn -g` and a current time
    * send configuration to the current pubsub channel:
          topic <- encrypt(MD5(OTP2), json(configuration))
          // OTP2 - Time-based OTP based on `edgevpn -g` and a current time.

* on update event (configuration has been updated by somebody):
    * read configuration from the current pubsub channel:
          msg <- topic
          plaintext = decrypt(MD5(OTP2), msg)
          // OTP2 - Time-based OTP based `edgevpn -g` and a current time.
```

[OTP1](https://github.com/mudler/edgevpn/blob/master/pkg/hub/hub.go#L56) 
and [OTP2](https://github.com/mudler/edgevpn/blob/master/pkg/node/connection.go#L117) 
are based on `edgevpn -g` token, it is expected that OTP1 and OTP2 are unique (no way to guess OTP without a EdgeVPN token)
and shared by all instances that use the same token:

```go
# OTP1
func (m *MessageHub) topicKey(salts ...string) string {
    totp := gotp.NewTOTP(strings.ToUpper(m.otpKey), m.keyLength, m.interval, nil)
    if len(salts) > 0 {
        return crypto.MD5(totp.Now() + strings.Join(salts, ":"))
    }
    return crypto.MD5(totp.Now())
}

# OTP2
func (e *Node) sealkey() string {
    return internalCrypto.MD5(gotp.NewTOTP(e.config.ExchangeKey, e.config.SealKeyLength, e.config.SealKeyInterval, nil).Now())
}
```

Library https://github.com/xlzd/gotp is used to generate the OTPs.

**The issue is that there is not enough randomness in `sealKey()` and `topicKey()`. 
NewTOTP(..).Now() returns an integer with leading zeros.**
```go
gotp.NewTOTP(randomString, 32, rotateInterval, nil).Now()        // returns something like "00000000000000000000000814612787"
gotp.NewTOTP(anotherRandomString, 16, rotateInterval, nil).Now() // returns something like "0000000814612787"
```

This means: 
1. **EdgeVPN encrypts configuration using only 10^9 different keys.**
This makes it possible to decrypt any message taken from a pubsub channel instantly.
Once an attacker decrypts a message, he knows OTP2 and can upload his malformed configuration to be consumed by all other instances.
Such malformed configuration can allow joining the private network and use the network's services like `egress`.
2. **EdgeVPN uses only 10^9 different pubsub channels.** 
So an attacker can subscribe to 10^9 pubsub channels up front.
 
